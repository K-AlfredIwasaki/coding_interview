Priorities
### 1 Graph
### 2 Merge Sort
### 3 Permutation
### 4 Tree

Arrays
1.01 Binary Search --- Easy
1.02 Find Maximum in Sliding Window 
1.03 Search rotated array
1.04 Find smallest common number
1.05 Rotate Array
1.06 Find low/high index --- twisted binary search
1.07 Move zeros to left
1.08 Find maximum single sell profit
1.09 Implement Quicksort
1.10 Merge Overlapping Intervals
1.11 Sum of Two Values

Linked List
2.0 

Math & Stats
x2 on 10/8 3.01 Find kth permutation --- key is (k-1) / blocksize
retry --- x2 on 10/8 3.02 Integer Division --- key is quotient <<= 1 (equivalent of q = q + 1) and quotient >>= 1
retry --- x2 on 10/8 3.04 All Sum Combinations --- keys are for loop version recursion, results.pop(), range(start, target)


Tree
6.05 Level Order Traversal of Binary Tree --- 10/8 --- easy. simple BFS
6.08 Print Tree Perimeter ---10/8--------- Retry --- key is how not to print leaf (root.left != None, root.right != None)

Graph
7.02 Minimum Spanning Tree --- 10/8 ------- Retry very hard --- Use PriorityQueue(Heap)

Dynamic Programming 
9.01 Fibonacci numbers --- One more time --- key is to store n_1 and n_2
9.02 Largest Sum Subarray --- Retry --- Similar to 1.02, 1.08
9.03 MaxSum Subsequence - Nonadjacent Elements -------- Key is result = max(n_1, n_2 + current_num)


