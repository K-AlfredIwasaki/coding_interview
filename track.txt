Priorities
### 1 Graph
### 2 Merge Sort
### 3 Permutation
### 4 Tree

10/11 Review Graph + LinkedList  - Merge Sort / Reverse k Elements
10/12 Review Graph + Trees
10/13 Review Graph + Arrays
10/14 Review Graph + Math

Summarize --- Perumutation -----------------------------------------------------------------------------------
- 3.01 Find kth permutation      ---  block size
- 3.04 All Sum Combinations      ---  back tracking
- 3.06 Permute String            ---  back tracking
- 3.07 All Subsets               ---
- 8.02 All Possible Parentheses  ---
- 9.04 Game Scoring              ---
- 9.05 Cooin Changing Problem    --- 


Arrays -------------------------------------------------------------------------------------------------------
1.01 Binary Search --- Easy
1.02 Find Maximum in Sliding Window 
1.03 Search rotated array
1.04 Find smallest common number
1.05 Rotate Array
1.06 Find low/high index --- twisted binary search
1.07 Move zeros to left
1.08 Find maximum single sell profit
1.09 Implement Quicksort
1.10 Merge Overlapping Intervals
1.11 Sum of Two Values

Linked List -------------------------------------------------------------------------------------------------------
          x2 on 10/12  2.05 Intersection Point of Two Lists
OK        x4 on 10/12  2.08 Merge two sorted linkedlist
OK        x2 on 10/12  2.09 Merge sort --- keys are two base cases (head == None and head.next == None) and a sequence (split, recursion, merge)
Retry --- x4 on 10/12  2.12 Reverse k Elements --- keys are big_head, c_tail, p_tail


Math & Stats -------------------------------------------------------------------------------------------------------
          x2 on 10/8   3.01 Find kth permutation --- key is (k-1) / blocksize
          x3 on 10/10  3.02 Integer Division --- key is quotient <<= 1 (equivalent of q = q + 1) and quotient >>= 1
          x3 on 10/10  3.04 All Sum Combinations --- keys are for loop version recursion, results.pop(), range(start, target)
Retry --- x2 on 10/10  3.07 All Subsets --- key is keeping input array --- back tracking
          x2 on 10/10  3.10 Calculate Square Root --- key is binary search approach --- lower/upper bound

Tree -------------------------------------------------------------------------------------------------------
Similar 5.02, 5.03, 5.06 In-order Traversal

          x2 on 10/11  5.01 Check if two binary trees are identical --- two version --- recursion and inorder/preorder --- key is to consider root1 != None but root2 == None
Retry --- x1 on 10/10  5.02 Write an Inorder Iterator for a Binary Tree --- Iterative Inorder Travesal with Stack
Retry --- x1 on 10/10  5.03 Iterative Inorder Traversal --- very similar to 5.02
Retry --- x2 on 10/13  5.04 Inorder Successor BST --- 1) iterative inorder traversal, 2) top down + findmin
Easy ---  x1 on 10/8   5.05 Level Order Traversal of Binary Tree ---  simple BFS
Retry --- x2 on 10/13  5.06 Is BST? --- one solution is min-/max-bound and the other is use global = prev
Retry ----x1 on 10/13  5.07 Convert Binary Tree To Doubly Linked List --- keys are recursive + concatenation
Almost -- x2 on 10/11  5.06 Is BST? -- Key is iterative inoder traversal + track the most recent value + try different solutions -- recursion + tracking
Almost -- x2 on 10/13  5.08 Print Tree Perimeter --- key is how not to print leaf (root.left != None, root.right != None)
Retry --- x2 on 10/11  5.10 Serialize/Deserialize Binary Tree --- key is recursion for both
Retry --- x1 on 10/14  5.11 Connect All Siblings --- Two trackers: one for parents and the other for children


Graph -------------------------------------------------------------------------------------------------------
Retry --- x1 on 10/8   7.02 Minimum Spanning Tree ------- very hard --- Use PriorityQueue(Heap)

Back Tracking -------------------------------------------------------------------------------------------------------

https://stackoverflow.com/questions/18066603/fastest-way-to-search-python-dict-with-partial-keyword
Not done yet ---          8.01 boggle ------ prefix search 
Must Retry --- x1 on 10/9 8.02 All Possible Parentheses ------ Keys are recursion, (if, if, if), pop, temp = current.copy() when putting in result[]

Dynamic Programming -------------------------------------------------------------------------------------------------------
Retry                  9.01 Fibonacci numbers --- key is to store n_1 and n_2
Retry --- x1 on        9.02 Largest Sum Subarray --- Similar to 1.02, 1.08
                       9.03 MaxSum Subsequence - Nonadjacent Elements -------- Key is result = max(n_1, n_2 + current_num)
Retry --- x1 on 10/10  9.04 Game Scoring --- key is table or dp
Retry --- x1 on 10/9   9.05 Coin Changing Problem --- Two version --- one is recursion (back tracking) and the other is dynamic programming (table)


Miscellaneous -------------------------------------------------------------------------------------------------------
Almost --- x1 on 10/10 10.02 Make Columns and Rows Zeros --- no efficient solution --- key is find index of zero cols and rows
Almost --- x1 on 10/10 10.03 Search in a Matrix --- key is to start from the top left to utilize its unique property (=> down is higher, right is lower)


Recursive solution has O(h) memory complexity as it will consume memory on the stack up to the height of binary tree h. It will be O(logn) for balanced tree and in worst case can be O(n).

